name: Build and Release
on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'bugfix'
        type: choice
        options:
          - bugfix   # Increment patch (x.y.Z)
          - feature  # Increment minor (x.Y.0)
          - major    # Increment major (X.0.0)
      prerelease:
        description: 'Is this a prerelease?'
        required: true
        default: false
        type: boolean

env:
  PROJECT_NAME: go-acme-dns-manager

permissions:
  contents: write

jobs:
  create-tag:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.generate_version.outputs.version }}
    steps:
      - name: Checkout code with history
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Generate new version
        id: generate_version
        run: |
          set -euo pipefail
          # Get the latest tag from git
          git fetch --tags
          LATEST_TAG=$(git describe --tags --match 'v*' --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Parse the latest tag to get major, minor, and patch
          MAJOR=$(echo $LATEST_TAG | sed -E 's/v([0-9]+)\.([0-9]+)\.([0-9]+).*/\1/')
          MINOR=$(echo $LATEST_TAG | sed -E 's/v([0-9]+)\.([0-9]+)\.([0-9]+).*/\2/')
          PATCH=$(echo $LATEST_TAG | sed -E 's/v([0-9]+)\.([0-9]+)\.([0-9]+).*/\3/')
          
          echo "Current version: $MAJOR.$MINOR.$PATCH"
          
          # Increment based on release type
          case "${{ github.event.inputs.release_type }}" in
            major)
              MAJOR=$((MAJOR+1))
              MINOR=0
              PATCH=0
              ;;
            feature)
              MINOR=$((MINOR+1))
              PATCH=0
              ;;
            bugfix)
              PATCH=$((PATCH+1))
              ;;
          esac
          
          # Generate new version
          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Also create a version without the v prefix for CHANGES.md
          echo "version_no_v=$MAJOR.$MINOR.$PATCH" >> $GITHUB_OUTPUT
          
          # Get current date in YYYY-MM-DD format
          RELEASE_DATE=$(date +%Y-%m-%d)
          echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          
      - name: Update CHANGES.md
        run: |
          set -euo pipefail
          # Get current date in YYYY-MM-DD format
          RELEASE_DATE=${{ steps.generate_version.outputs.release_date }}
          VERSION_NO_V=${{ steps.generate_version.outputs.version_no_v }}
          
          # Update CHANGES.md - Move Unreleased changes to new version section
          sed -i "s/## \[Unreleased\]/## [Unreleased]\n\n## [${VERSION_NO_V}] - ${RELEASE_DATE}/" CHANGES.md
          
          echo "Updated CHANGES.md for version ${VERSION_NO_V}"

      - name: Commit and Create tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          set +x
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          VERSION="${{ steps.generate_version.outputs.version }}"
          
          # Commit CHANGES.md update
          git add CHANGES.md
          git commit -m "Update CHANGES.md for release ${VERSION}"
          
          # Create and push tag
          git tag -a ${VERSION} -m "Release ${VERSION}"
          git push origin main
          git push origin ${VERSION}

  build:
    needs: create-tag
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-tag.outputs.version }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.1'

      - name: Build and Package All Platforms
        id: build_package
        env:
          VERSION: ${{ needs.create-tag.outputs.version }}
        run: |
          set -euxo pipefail
          ARCHIVES_DIR="release-archives"
          mkdir -p "$ARCHIVES_DIR"

          # Define target platforms with their archive formats
          declare -A targets=(
            ["linux/amd64"]="tar.gz"
            ["linux/arm64"]="tar.gz"
            ["windows/amd64"]="zip"
            ["windows/arm64"]="zip"
            ["darwin/amd64"]="zip"
            ["darwin/arm64"]="zip"
            ["illumos/amd64"]="tar.gz"
          )

          for target in "${!targets[@]}"; do
            GOOS=$(echo $target | cut -d'/' -f1)
            GOARCH=$(echo $target | cut -d'/' -f2)
            ARCHIVE_TYPE=${targets[$target]}
            EXTENSION=""
            if [ "$GOOS" = "windows" ]; then
              EXTENSION=".exe"
            fi

            echo "Building for $GOOS/$GOARCH..."
            # Create a temporary dir for each build to avoid conflicts
            TEMP_BUILD_DIR="build_temp_${GOOS}_${GOARCH}"
            mkdir -p "$TEMP_BUILD_DIR"
            BINARY_NAME="${{ env.PROJECT_NAME }}${EXTENSION}"
            
            # Build directly into the temp dir
            GOOS=$GOOS GOARCH=$GOARCH go build -o "$TEMP_BUILD_DIR/$BINARY_NAME" ./cmd/${{ env.PROJECT_NAME }}

            # Prepare package contents within the temp dir
            PKGDIR_BASE="${{ env.PROJECT_NAME }}-${VERSION}-${GOOS}-${GOARCH}"
            PKGDIR_CONTENTS="$TEMP_BUILD_DIR/$PKGDIR_BASE"
            mkdir -p "$PKGDIR_CONTENTS"
            mv "$TEMP_BUILD_DIR/$BINARY_NAME" "$PKGDIR_CONTENTS/" # Move the built binary
            cp config.yaml "$PKGDIR_CONTENTS/config-sample.yaml"
            cp README.md "$PKGDIR_CONTENTS/"
            cp CHANGES.md "$PKGDIR_CONTENTS/"
            [ -f LICENSE ] && cp LICENSE "$PKGDIR_CONTENTS/"

            # Create archive from the temp dir, placing it in ARCHIVES_DIR
            ARCHIVE_NAME="$PKGDIR_BASE.$ARCHIVE_TYPE"
            # Make sure the archives directory exists (might be removed when cd'ing)
            mkdir -p "$ARCHIVES_DIR"
            
            # Save the current working directory
            CURRENT_DIR=$(pwd)
            
            # Change to temp build directory for archiving
            cd "$TEMP_BUILD_DIR"
            if [ "$ARCHIVE_TYPE" = "zip" ]; then
              # Create parent directory structure if it doesn't exist
              mkdir -p "$(dirname "$CURRENT_DIR/$ARCHIVES_DIR/$ARCHIVE_NAME")"
              zip -r "$CURRENT_DIR/$ARCHIVES_DIR/$ARCHIVE_NAME" "$PKGDIR_BASE"
            else
              # Create parent directory structure if it doesn't exist
              mkdir -p "$(dirname "$CURRENT_DIR/$ARCHIVES_DIR/$ARCHIVE_NAME")"
              tar -czvf "$CURRENT_DIR/$ARCHIVES_DIR/$ARCHIVE_NAME" "$PKGDIR_BASE"
            fi
            
            # Return to original directory
            cd "$CURRENT_DIR"
            
            # Clean up temp build dir for this platform
            rm -rf "$TEMP_BUILD_DIR"
          done

          echo "All builds and packages complete."
          echo "Generated archives in $ARCHIVES_DIR:"
          ls -l "$ARCHIVES_DIR"

      - name: List files for debug
        run: find release-archives -type f

      - name: Upload all release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts # Upload all archives under this single artifact name
          path: release-archives # Path to the directory containing all archives

  create-release:
    needs: [build, create-tag]  # Add explicit dependency on create-tag to access its outputs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code for release notes
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-tag.outputs.version }}

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts # Name of the artifact to download
          path: release-archives/ # Path to download the artifact to
        # This will download the single 'release-artifacts' artifact
        # It will create a directory named 'release-artifacts' containing all the archives

      - name: List artifacts
        run: find . -type f

      - name: Extract release notes
        id: extract_release_notes
        run: |
          set -e
          
          # Extract version number without 'v' prefix for CHANGES.md
          VERSION_NO_V=$(echo "${{ needs.create-tag.outputs.version }}" | sed 's/^v//')
          echo "Looking for version: ${VERSION_NO_V}"
        
          # Use Perl to extract the relevant section - much more reliable than bash/awk
          perl -e '
            # Get version from first argument
            my $version = $ARGV[0];
            
            # Read the entire CHANGES.md file
            undef $/;
            my $content = <STDIN>;
            
            # Use a regex to find the section for our version
            if ($content =~ /## \[\Q$version\E\][^\n]*\n(.*?)(?=\n## \[|$)/s) {
              my $section = $1;
              # Trim leading/trailing whitespace
              $section =~ s/^\s+|\s+$//g;
              print $section;
            } else {
              # Not found, create minimal content
              print "Release version $version\n";
              warn "WARNING: Could not find version $version in CHANGES.md\n";
            }
          ' "$VERSION_NO_V" < CHANGES.md > release_notes_final.md
          
          # Show the result
          echo "Release notes extracted to release_notes_final.md:"
          cat release_notes_final.md

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-tag.outputs.version }}
          name: Release ${{ needs.create-tag.outputs.version }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease }}
          body_path: release_notes_final.md
          fail_on_unmatched_files: true
          files: release-archives/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
